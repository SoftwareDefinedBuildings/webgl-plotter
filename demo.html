<html>
    <head>
        <title>WebGL Plotting Tool</title>
        <style>
            body {
                margin: 0;
            }
        </style>
    </head>
    <body>
        <script src="http://threejs.org/build/three.min.js"></script>
        <script>
            var hToW = 1; // the ratio of height to width, which may change throughout the program
            var height; // should not be changed manually. Set by updateScreenSize.
            var width; // should not be changed manually. Set by updateScreenSize.
            function updateScreenSize() {
                width = window.innerWidth - 15; // 15 is the width of the scrollbar, measured experimentally
                canvas.style.width = width;
                height = hToW * width;
                canvas.style.height = height
                camera = new THREE.OrthographicCamera(-100, 100, 100, 100 - 200 * hToW, 0.1, 1000)
                renderer.setSize(width, height);
            }
            
            window.onresize = updateScreenSize;
        
            function ColorBox(width, height, depth) {
                var geom = new THREE.BoxGeometry(width, height, depth);
                var material = new THREE.MeshBasicMaterial({color: 0xffffff});
                this.obj = new THREE.Mesh(geom, material);
                this.obj.click = this.click.bind(this); // an extra parameter I'm adding
                this.target = null;
                this.selected = false;
            }
            
            ColorBox.prototype.addToScene = function () {
                scene.add(this.obj);
                objs.push(this.obj);
            }
            
            ColorBox.prototype.setPosition = function (x, y, z) {
                this.obj.position.set(x, y, z);
            }
            
            ColorBox.prototype.setTarget = function (otherBox) {
                this.target = otherBox;
            }
            
            ColorBox.prototype.click = function () {
                if (this.target.selected) {
                    this.target.obj.material.setValues({color: 0xffffff});
                    this.target.selected = false;
                } else {
                    this.target.obj.material.setValues({color: 0xff0000});
                    this.target.selected = true;
                }
            }
        
            var scene = new THREE.Scene();
            var objs = [];
            var camera;
            
            var renderer = new THREE.WebGLRenderer();
            
            var canvas = renderer.domElement;
            document.body.appendChild(canvas);
            
            updateScreenSize();
            
            var boxes = [null, null, null, null];
            for (var i = 0; i < 4; i++) {
                boxes[i] = new ColorBox(2, 2, 0.1);
                boxes[i].addToScene(scene);
            }
            boxes[0].setPosition(-10, -10, -20);
            boxes[1].setPosition(10, -10, -20);
            boxes[2].setPosition(-10, 10, -20);
            boxes[3].setPosition(10, 10, -20);
            
            boxes[0].setTarget(boxes[3]);
            boxes[3].setTarget(boxes[0]);
            boxes[1].setTarget(boxes[2]);
            boxes[2].setTarget(boxes[1]);

            var render = function () {
                    requestAnimationFrame( render );
                    renderer.render(scene, camera);
                };
            render();
            
            document.onclick = function (event) {
                    var coordX = event.clientX / (width / 2) - 1;
                    var coordY = -1 * ((event.clientY + document.body.scrollTop) / (height / 2) - 1);
                    var mouseClick = new THREE.Vector3(coordX, coordY, 0);
                    
                    mouseClick.unproject(camera); // get the coordinates in 3D space
                    mouseClick.setZ(0);
                    
                    // The normal vector happens to be <0, 0, -1> for the camera. If the camera tilts, that will change.
                    var ray = new THREE.Raycaster(mouseClick, new THREE.Vector3(0, 0, -1));
                    var intersections = ray.intersectObjects(objs);
                    
                    var obj;
                    if (intersections.length > 0) {
                        obj = intersections[0].object;
                        if (obj.hasOwnProperty("wrapper") && "click" in obj.wrapper) {
                            obj.wrapper.click();
                        }
                    }
                };
        </script>
    </body>
</html>
